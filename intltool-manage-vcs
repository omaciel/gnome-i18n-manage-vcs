#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

# Author  : Simos Xenitellis <simos@gnome.org>
# Version : 0.8

import sys		# sys.argv, sys.exit()
import os		# os.system(), os.remove()
import getopt		# getopt.getopt()
import urllib		# urllib.urlretrieve()
from lxml import etree  # etree.XMLParser(), etree.XML()

PROGNAME='intltool-manage-vcs'

class GNOMEI18nTarget:
	def __init__(self):
		self.message_states = ['translated', 'untranslated', 'fuzzy', 'docfuzzy', 'docuntranslated', 'doctranslated']
		self.flags = []

		self.stats_release = None
		self.stats_language = None

		self.category_id = None

		self.module_id = None
		self.module_branch = None		

		self.domain = None
		self.document = None

		self.pofile = None
		self.vcspath = None

		self.resources = []
		self.module = {}
		self.category = {}
		self.stats = {}

	def start(self, tag, attrib):
		if tag not in self.message_states:
			if tag == 'domain':
				self.domain = attrib['id']
			elif tag == 'document':
				self.document = attrib['id']
			elif tag == 'module':
				self.module_id = attrib['id']
				self.module_branch = attrib['branch']
			elif tag == 'category':
				self.category_id = attrib['id']
			elif tag == 'stats':
				self.stats_release = attrib['release']
				self.stats_language = attrib['language']
			elif tag not in ['pofile', 'svnpath']:
				# Should not be reached
				#print self.tabs[:self.level], ("start %s %s" % (tag, attrib))
				pass
			self.push_flag(tag)

        def end(self, tag):
		if tag not in self.message_states:
			if tag == 'domain':
				self.resources.append({'id': tag, 'type': self.domain, 
					'pofile': self.pofile, 'vcspath' : self.vcspath }) 
				self.domain = self.pofile = self.vcspath = None
			elif tag == 'document':
				self.resources.append({'id': tag, 'type': self.document, 
					'pofile': self.pofile, 'vcspath' : self.vcspath }) 
				self.document = self.pofile = self.vcspath = None
			elif tag == 'module':
				self.module[self.module_id] = { 'branch': self.module_branch, 'resource': self.resources }
				self.module_id = self.module_branch = None
				self.resources = []
			elif tag == 'category':
				self.category[self.category_id] = self.module
				self.module = {}
				self.category_id = None
			elif tag == 'stats':
				self.stats = { 'language': self.stats_language, 'release': self.stats_release, 
						'categories': self.category } 
				self.category = {}
				self.stats_release = self.stats_language = None
			elif tag not in ['pofile', 'svnpath']:
				# Should not be reached
            			#print self.tabs[:self.level], ("end %s" % tag)
				pass
			self.pop_flag(tag)

        def data(self, data):
	    	if not data.isspace() and not data.isdigit():
			if self.flags[-1] == 'pofile':
				self.pofile = data
			elif self.flags[-1] == 'svnpath':
				self.vcspath = data
			else:
				# Should not be reached
            			#print self.tabs[:self.level], ("data %r" % data)
				pass

        def comment(self, text):
		pass

        def close(self):
            	return True

	def push_flag(self, tag):
		self.flags.append(tag)

	def pop_flag(self, tag):
		if self.flags.pop() != tag:
			print "ERROR, did not pop", tag

	def get_stats(self):
		return self.stats

class GNOMEI18nManage:
	language = ''
	username = ''
	release = ''

	category = ''
	module = ''

	xmlurl = ''
	xmlfilename = ''

	opt_quiet = False
	opt_status = False

	def __init__(self, argv):
		try:
		        opts, args = getopt.getopt(argv[1:], "hl:qr:su:", ["help", "category=", "module=",
							"language=", "quiet", "release=", "status", 
							"username=" ])
		except getopt.GetoptError, err:
			print "Error", err
        		self.usage()
        		sys.exit(0)


		for o, a in opts:
		        if o in ("-h", "--help"):
       		  	     	usage()
                	     	sys.exit()
        		if o in ("-c", "--category"):
                		self.category = a
        		if o in ("-m", "--module"):
                		self.module = a
        		if o in ("-l", "--language"):
                		self.language = a
        		if o in ("-q", "--quiet"):
                		self.opt_quiet = True
			if o in ("-r", "--release"):
			 	self.release = a
     			if o in ("-s", "--status"):
				opt_status = True
        		if o in ("-u", "--username"):
                		self.username = a

		if self.language == '' or self.release == '' or self.username == '':
			print "Error: Required parameters missing"
			self.usage()
			sys.exit(-1)

		self.xmlurl = "http://l10n.gnome.org/languages/" + self.language + "/gnome-2-26/xml"
		self.xmlfilename = self.download_file(self.xmlurl)

		try:
			xmlfile = open(self.xmlfilename, 'r')
			xmlfile.close
		except OSError:
			print "Could not open file ", xmlfilename, ". Aborting..."
			sys.exit(-1)
	
		contents = "".join(xmlfile.readlines())
		
		mytarget = GNOMEI18nTarget()
		parser = etree.XMLParser(target = mytarget)
		result = etree.XML(contents, parser)
	
		stats = mytarget.get_stats()
	
		release = stats['release']
		language = stats['language']
		print "Release  :", release
		print "Language :", language
		for cat in stats['categories'].keys():
			if self.category != '' and cat != self.category:
				continue
			print "\tCategory:", cat
			for mod in stats['categories'][cat]:
				if self.module != '' and mod != self.module:
					continue
				print "\t\tModule:", mod
				print "\t\t\tBranch:", stats['categories'][cat][mod]['branch']
				for resource in stats['categories'][cat][mod]['resource']:
					print "\t\t\t\tID:", resource['id'], "Type:", resource['type']
					print "\t\t\t\t\tPOFile:", resource['pofile']
					print "\t\t\t\t\tVCSPath:", resource['vcspath']
					pofilename = resource['pofile'].rpartition('/')[2]
					vcspathtemp = resource['vcspath'].replace('/viewvc/', '/svn/')
					vcspath = vcspathtemp.replace('http://', 'svn+ssh://' + self.username + '@')
					branch = stats['categories'][cat][mod]['branch']
					CMD1 = 'svn co ' + vcspath + ' VCS/' + mod + '@' + branch
					CMD2 = 'wget http://l10n.gnome.org' + resource['pofile'] + ' -O PO/' + pofilename
					CMD3 = 'ln -s ../VCS/' + mod + '@' + branch + '/' + language + '.po LINKS/' + pofilename
					#print "\t\t\t\t\tCMD:", CMD1
					#print "\t\t\t\t\tCMD:", CMD2
					#print "\t\t\t\t\tCMD:", CMD3
					#os.system(CMD1)
					#os.system(CMD2)
					#os.system(CMD3)
	
	
	def usage(self):
		print PROGNAME, 'a tool that helps manage translation files from a VCS'
	        print """Available parameters:
   	    	 -h     --help              this craft
		 -c CAT --category CAT     i18n category name CAT (such as 'desktop')
		 -m MOD --module MOD       i18n module name MOD (such as 'gnome-games')
		 -l LL  --language LL       language code per ISO 639 (REQUIRED)
		 -r REL --release REL       release REL (such as 'gnome-2-26') (REQUIRED)
       		 -s     --status            show status
		 -u USR --username USR      username USR (corresponds to SVN/GIT GNOME account) (REQUIRED)
       		 -v     --verbose           show verbose output

        	Default is to show this help text."""

	def download_hook(self, blocks_transferred, block_size, file_size):
	        """ A download hook to provide some feedback when downloading """
	        if blocks_transferred == 0:
	                if file_size > 0:
       		                 if not self.opt_quiet:
                	                print "Downloading", file_size, "bytes: ",
               		else:
                        	if not self.opt_quiet:
                                	print "Downloading: ",
		if not opt_quiet:
        		sys.stdout.write('#')
        		sys.stdout.flush()


	def download_file(self, url):
	        """ Downloads a file provided a URL. Returns the filename. """
	        """ Borks on failure """
	        localfilename = 'managevcs-' + self.language + '-' + self.release + '.' + url.split('/')[-1]
	        if not os.path.isfile(localfilename) or os.path.getsize(localfilename) <= 0:
	                if not self.opt_quiet:
	                        print "Downloading ", url, "..."
	                try:
				if os.path.getsize(localfilename) <= 0:
					os.remove(localfilename)
	                        urllib.urlretrieve(url, localfilename, self.download_hook)
	                except IOError, (errno, strerror):
	                        print "I/O error(%s): %s" % (errno, strerror)
	                        sys.exit(-1)
	                except:
	                        print "Unexpected error: ", sys.exc_info()[0]
	                        sys.exit(-1)
			if not opt_quiet:
	                	print " done."
	        else:
	                if not self.opt_quiet:
        	                print "Using cached file for ", url
	        return localfilename

start = GNOMEI18nManage(sys.argv)
