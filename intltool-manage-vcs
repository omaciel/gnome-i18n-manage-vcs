#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

# Author  : Simos Xenitellis <simos@gnome.org>
# Version : 0.8

import dircache		# dircache.listdir()
import os		# os.system(), os.remove(), os.path.gmtime()
import getopt		# getopt.getopt()
import shutil		# shutil.rmtree()
import sys		# sys.argv, sys.exit()
import urllib		# urllib.urlretrieve()

from lxml import etree  # etree.XMLParser(), etree.XML()

PROGNAME='intltool-manage-vcs'

class GNOMEI18nTarget:
	def __init__(self):
		self.message_states = ['translated', 'untranslated', 'fuzzy', 'docfuzzy', 'docuntranslated', 'doctranslated']
		self.flags = []

		self.stats_release = None
		self.stats_language = None

		self.category_id = None

		self.module_id = None
		self.module_branch = None		

		self.domain = None
		self.document = None

		self.pofile = None
		self.vcspath = None

		self.resources = []
		self.module = {}
		self.category = {}
		self.stats = {}

	def start(self, tag, attrib):
		if tag not in self.message_states:
			if tag == 'domain':
				self.domain = attrib['id']
			elif tag == 'document':
				self.document = attrib['id']
			elif tag == 'module':
				self.module_id = attrib['id']
				self.module_branch = attrib['branch']
			elif tag == 'category':
				self.category_id = attrib['id']
			elif tag == 'stats':
				self.stats_release = attrib['release']
				self.stats_language = attrib['language']
			elif tag not in ['pofile', 'svnpath']:
				# Should not be reached
				#print self.tabs[:self.level], ("start %s %s" % (tag, attrib))
				pass
			self.push_flag(tag)

        def end(self, tag):
		if tag not in self.message_states:
			if tag == 'domain':
				self.resources.append({'id': tag, 'type': self.domain, 
					'pofile': self.pofile, 'vcspath' : self.vcspath }) 
				self.domain = self.pofile = self.vcspath = None
			elif tag == 'document':
				self.resources.append({'id': tag, 'type': self.document, 
					'pofile': self.pofile, 'vcspath' : self.vcspath }) 
				self.document = self.pofile = self.vcspath = None
			elif tag == 'module':
				self.module[self.module_id] = { 'branch': self.module_branch, 'resource': self.resources }
				self.module_id = self.module_branch = None
				self.resources = []
			elif tag == 'category':
				self.category[self.category_id] = self.module
				self.module = {}
				self.category_id = None
			elif tag == 'stats':
				self.stats = { 'language': self.stats_language, 'release': self.stats_release, 
						'categories': self.category } 
				self.category = {}
				self.stats_release = self.stats_language = None
			elif tag not in ['pofile', 'svnpath']:
				# Should not be reached
            			#print self.tabs[:self.level], ("end %s" % tag)
				pass
			self.pop_flag(tag)

        def data(self, data):
	    	if not data.isspace() and not data.isdigit():
			if self.flags[-1] == 'pofile':
				self.pofile = data
			elif self.flags[-1] == 'svnpath':
				self.vcspath = data
			else:
				# Should not be reached
            			#print self.tabs[:self.level], ("data %r" % data)
				pass

        def comment(self, text):
		pass

        def close(self):
            	return True

	def push_flag(self, tag):
		self.flags.append(tag)

	def pop_flag(self, tag):
		if self.flags.pop() != tag:
			print "ERROR, did not pop", tag

	def get_stats(self):
		return self.stats

class GNOMEI18nManage:
	language = ''
	username = ''
	release = ''

	category = ''
	module = ''
	transtype = ''		# either 'doc' or 'ui' ('document' or 'domain')

	xmlurl = ''
	xmlfilename = ''

	dir_po = 'PO/'
	dir_vcs = 'VCS/'
	dir_links = 'LINKS/'
	file_START = 'START'
	file_README = 'README'

	opt_apply = False
	opt_commit = False
	opt_dryrun = False
	opt_init = False
	opt_blank = False
	opt_quiet = False
	opt_status = False
	opt_svnquiet = False

	def __init__(self, argv):
		if not argv[1:]:
			self.usage()
			sys.exit(0)

		try:
		        opts, args = getopt.getopt(argv[1:], "abc:dhil:qr:st:u:", ["apply", "blank", 
							"category=", "commit", "dryrun", "dry-run", "help", 
							"init", "module=", "language=", "quiet", 
							"release=", "status", "svnquiet", "transtype=", "username=" ])
		except getopt.GetoptError, err:
			print "Error", err
        		self.usage()
        		sys.exit(0)

		for o, a in opts:
        		if o in ("-a", "--apply"):
                		self.opt_apply = True
        		if o in ("-b", "--blank"):
                		self.opt_blank = True
        		if o in ("-c", "--category"):
                		self.category = a
        		if o in ("--commit"):
                		self.opt_commit = True
        		if o in ("--dryrun", "--dry-run"):
                		self.opt_dryrun = True
		        if o in ("-h", "--help"):
       		  	     	self.usage()
                	     	sys.exit()
        		if o in ("-i", "--init"):
                		self.opt_init = True
        		if o in ("-m", "--module"):
                		self.module = a
        		if o in ("-l", "--language"):
                		self.language = a
        		if o in ("-q", "--quiet"):
                		self.opt_quiet = True
			if o in ("-r", "--release"):
			 	self.release = a
     			if o in ("-s", "--status"):
				self.opt_status = True
     			if o in ("--svnquiet"):
				self.opt_svnquiet = True
     			if o in ("--transtype"):
				if a in ['ui', 'domain']:
					self.transtype = 'domain'
				elif a in ['doc', 'document']:
					self.transtype = 'document'
				else:
					print "ERROR: Invalid transtype, expected on of ui, doc, domain, document"
					sys.exit(-4)
        		if o in ("-u", "--username"):
                		self.username = a

		if self.opt_status:
			if self.is_empty():
				print "Directories are empty"
			else:
				print "Directories are not empty"
			sys.exit(0)

		if self.opt_apply:
			if self.is_empty():
				print "Directories are empty, cannot apply translation changes; exiting"
				sys.exit(-3)
			self.apply_translation_changes()
			sys.exit(0)

		if self.opt_commit:
			if self.is_empty():
				print "Directories are empty, cannot commit translation changes; exiting"
				sys.exit(-3)
			self.do_commit()

		if self.opt_init and (self.language == '' or self.release == '' or self.username == ''):
			print "Error: Required parameter(s) missing for initialisation"
			self.usage()
			sys.exit(-1)

		if self.opt_init:
			if not self.is_empty():
				print "ERROR: Cannot init when directories are not empty"
				sys.exit(-2)
			else:
				self.init()

		if self.opt_blank:
			self.do_blank()

	def apply_translation_changes(self):
		dircontents = dircache.listdir(self.dir_po)
		dircontents = dircontents[:]
		dircontents.remove(self.file_README)	
		start_time = os.stat(self.dir_po + self.file_START).st_mtime
		for pofile in dircontents:
			if start_time < os.stat(self.dir_po + pofile).st_mtime:
				if not self.opt_quiet:
					print "Copying", self.dir_po + pofile, "to", self.dir_links + pofile
				if not self.opt_dryrun:
					shutil.copyfile(self.dir_po + pofile, self.dir_links + pofile)

	def do_commit(self):
		dircontents = dircache.listdir(self.dir_vcs)
		dircontents = dircontents[:]
		dircontents.remove(self.file_README)	
		for vcsdir in dircontents:
			if not self.opt_quiet:
				print "Committing in", self.dir_vcs + vcsdir
			cmd_commit = 'svn commit -m ' + '"Updated ' + self.language + ' translation"'
			cmd_changedir = 'chdir ' + self.dir_vcs + vcsdir
			if self.opt_dryrun:
				print cmd_changedir + ';' + cmd_commit
			else:
				os.system(cmd_changedir + ';' + cmd_commit)

	def is_empty(self):
		for dir in [self.dir_po, self.dir_vcs, self.dir_links]:
			dircontents = dircache.listdir(dir)
			dircontents = dircontents[:]
			dircontents.remove(self.file_README)	
			if dircontents:
				return False
		return True

	def do_blank(self):
		for dir in [self.dir_po, self.dir_vcs, self.dir_links]:
			dircontents = dircache.listdir(dir)
			dircontents = dircontents[:]
			dircontents.remove(self.file_README)	
			if dircontents:
				for item in dircontents:
					if os.path.isdir(dir + item):
						if not self.opt_quiet:
							print "Removing directory tree", dir + item
						if not self.opt_dryrun:
							shutil.rmtree(dir + item)
					else:
						if not self.opt_quiet:
							print "Removing file", dir + item
						if not self.opt_dryrun:
							os.remove(dir + item)

	def init(self):	
		if self.opt_dryrun:
			self.process_stats('print')
		else:
			self.process_stats('execute')

	def process_stats(self, action):	
		self.xmlurl = "http://l10n.gnome.org/languages/" + self.language + "/gnome-2-26/xml"
		self.xmlfilename = self.download_file(self.xmlurl)

		stats = self.parse_gnome_xml_file(self.xmlfilename)
	
		release = stats['release']
		language = stats['language']
		print "Release  :", release
		print "Language :", language
		for cat in stats['categories'].keys():
			if self.category != '' and cat != self.category:
				continue
			print "\tCategory:", cat
			for mod in stats['categories'][cat]:
				if self.module != '' and mod != self.module:
					continue
				print "\t\tModule:", mod
				print "\t\t\tBranch:", stats['categories'][cat][mod]['branch']
				for resource in stats['categories'][cat][mod]['resource']:
					if self.transtype: 
						if resource['id'] not in self.transtype:
							continue
					print "\t\t\t\tID:", resource['id'], "Type:", resource['type']
					print "\t\t\t\t\tPOFile:", resource['pofile']
					print "\t\t\t\t\tVCSPath:", resource['vcspath']
					pofilename = resource['pofile'].rpartition('/')[2]
					vcspathtemp = resource['vcspath'].replace('/viewvc/', '/svn/')
					vcspath = vcspathtemp.replace('http://', 'svn+ssh://' + self.username + '@')
					branch = stats['categories'][cat][mod]['branch']
					alignment = ''
					if resource['type'] == 'help':
						alignment = 'el/'
						print "Setting alignment to ", alignment

					if self.opt_svnquiet:
						CMD1 = 'svn co --quiet ' + vcspath + ' ' + self.dir_vcs + mod + '@' + branch
						CMD2 = 'wget --quiet http://l10n.gnome.org' + resource['pofile'] + \
							' -O ' + self.dir_po + pofilename
						CMD3 = 'ln -s ../' + self.dir_vcs + mod + '@' + \
							branch + '/' + alignment + language + '.po ' + \
							self.dir_links + pofilename
					else:
						CMD1 = 'svn co ' + vcspath + ' ' + self.dir_vcs + mod + '@' + branch
						CMD2 = 'wget http://l10n.gnome.org' + resource['pofile'] + \
							' -O ' + self.dir_po + pofilename
						CMD3 = 'ln --verbose -s ../' + self.dir_vcs + mod + '@' + \
							branch + '/' + alignment + language + '.po ' + \
							self.dir_links + pofilename

					if action == 'print':
						print "\t\t\t\t\tCMD:", CMD1
						print "\t\t\t\t\tCMD:", CMD2
						print "\t\t\t\t\tCMD:", CMD3
					elif action == 'execute':
						print "\t\t\t\t\tTouching current time at", self.dir_po + self.file_START
						os.system("touch " + self.dir_po + self.file_START)
						print "\t\t\t\t\tCMD:", CMD1
						os.system(CMD1)
						print "\t\t\t\t\tCMD:", CMD2
						os.system(CMD2)
						print "\t\t\t\t\tCMD:", CMD3
						os.system(CMD3)
						try:
							os.stat(self.dir_links + pofilename)
						except OSError, err:
							print "ERROR: We did not create the link properly"
							print "This is an internal error in the script"
							print "Please clear the mess with --blank and check the source"
							print "Now exiting..."
							sys.exit(-5)
	
	def parse_gnome_xml_file(self, filename):
		try:
			xmlfile = open(filename, 'r')
			xmlfile.close
		except OSError:
			print "Could not open file ", filename, ". Aborting..."
			sys.exit(-1)
	
		contents = "".join(xmlfile.readlines())
		
		mytarget = GNOMEI18nTarget()
		parser = etree.XMLParser(target = mytarget)
		result = etree.XML(contents, parser)
	
		return mytarget.get_stats()

	def usage(self):
		print PROGNAME, 'a tool that helps manage translation files from a VCS'
	        print """Available parameters:
   	    	 -a     --apply             copy changed translations to repositories
   	    	 -b     --blank             blanks and clears the downloaded files
		 -c CAT --category CAT      i18n category name CAT (such as 'desktop')
		        --commit	    commit changes in repositories
		 -d	--dry-run	    do not really checkout/commit/apply 
   	    	 -h     --help              this craft
		 -i     --init              when initialising, --language, --release, 
					     and --username are REQUIRED.
		 -m MOD --module MOD        i18n module name MOD (such as 'gnome-games')
		 -l LL  --language LL       language code per ISO 639
		 -r REL --release REL       release REL (such as 'gnome-2-26')
       		 -s     --status            show status
		 -t	--transtype=TYPE    optionally specify translation type, either ui or doc
		 -u USR --username USR      username USR (corresponds to SVN/GIT GNOME account)
       		 -v     --verbose           show verbose output

        	Default is to show this help text."""

	def download_hook(self, blocks_transferred, block_size, file_size):
	        """ A download hook to provide some feedback when downloading """
	        if blocks_transferred == 0:
	                if file_size > 0:
       		                 if not self.opt_quiet:
                	                print "Downloading", file_size, "bytes: ",
               		else:
                        	if not self.opt_quiet:
                                	print "Downloading: ",
		if not opt_quiet:
        		sys.stdout.write('#')
        		sys.stdout.flush()


	def download_file(self, url):
	        """ Downloads a file provided a URL. Returns the filename. """
	        """ Borks on failure """
	        localfilename = 'managevcs-' + self.language + '-' + self.release + '.' + url.split('/')[-1]
	        if not os.path.isfile(localfilename) or os.path.getsize(localfilename) <= 0:
	                if not self.opt_quiet:
	                        print "Downloading ", url, "..."
	                try:
				if os.path.getsize(localfilename) <= 0:
					os.remove(localfilename)
	                        urllib.urlretrieve(url, localfilename, self.download_hook)
	                except IOError, (errno, strerror):
	                        print "I/O error(%s): %s" % (errno, strerror)
	                        sys.exit(-1)
	                except:
	                        print "Unexpected error: ", sys.exc_info()[0]
	                        sys.exit(-1)
			if not opt_quiet:
	                	print " done."
	        else:
	                if not self.opt_quiet:
        	                print "Using cached file for ", url
	        return localfilename

start = GNOMEI18nManage(sys.argv)
